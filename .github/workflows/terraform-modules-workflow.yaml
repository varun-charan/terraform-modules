name: consume-custom-action

on:
  push:
    branches:
      # Meant for NETxxyy-* tickets
      - feature/*
      # Meant for DEVOPS-* tickets
      - hotfix/*
    # DO NOT trigger workflow run on updates to templates
    paths-ignore:
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
  pull_request:
    types:
      - open
      - closed
      - synchronize
    branches:
      # Meant for running after PR merged on master
      - master
    # DO NOT trigger workflow run on updates to templates
    paths-ignore:
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'
  # For manual trigger of job, if required. Avoids need to use dummy commits to initiate workflow.Applicable to master branch only since for it, source tag is picked from Git tags and not from Commit hash as is the case for dev branches.
  workflow_dispatch:

jobs:
  # U S I N G   P Y A C T I O N
  exec_command:
    runs-on: ubuntu-latest
    steps:
    - name: Test pyaction with exec devops cli command
      uses: varun-charan/pyaction@v0.5.0
      with:
        index_url_pip: ${{ secrets.INDEX_URL_PIP }}
        command: "exec"
        args: "python3 --version"
  
  non_exec_command:
    runs-on: ubuntu-latest
    outputs:
      stdout: ${{ steps.pyaction_non_exec_cmd.outputs.stdout }}
    steps:
    - name: Test pyaction with non-exec devops cli command
      id: pyaction_non_exec_cmd
      uses: varun-charan/pyaction@v0.5.0
      env:
        VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
        VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
      with:
        devops_version: "v0.5.0"
        index_url_pip: ${{ secrets.INDEX_URL_PIP }}
        export_list: "VAULT_ADDR=${{ env.VAULT_ADDR }}, VAULT_TOKEN=${{ env.VAULT_TOKEN }}"
        command: "vault"
        subcommand: "get"
        args: "prd/devops/newreleases automation_api_key"

  test_vault_output:
    runs-on: ubuntu-latest
    needs: [ non_exec_command ]
    steps:
      - name: Test if pyaction vault command returned correct output
        shell: bash
        run: |
          echo "::add-mask::$API_KEY"
          curl --location --request GET 'https://api.newreleases.io/v1/projects' --header 'X-Key: ${{ env.API_KEY }}'
        env:
          API_KEY: ${{ needs.non_exec_command.outputs.stdout }}

  # T E R R A F O R M   C I C D 
  get_target_modules:
    runs-on: ubuntu-latest
    outputs:
      tf_modules: ${{ steps.get_target_tf_modules.outputs.tf_modules }}
    steps:
      - name: Checkout application GitHub repo
        uses: actions/checkout@v3
      
      - name: Get target TF modules
        id: get_target_tf_modules
        shell: bash
        run: |
          git fetch origin master

          if [ -z `git diff --dirstat=files,0 --name-only $GITHUB_REF_NAME origin/master | grep -v .github` ]; then
            CHANGED_TF_MODULES_JSON=$(printf '[]\n')

            echo "TF Modules JSON: " $CHANGED_TF_MODULES_JSON
          else
            CHANGED_TF_MODULES=`git diff --dirstat=files,0 --name-only $GITHUB_REF_NAME origin/master | sed -E 's/^[ 0-9.]+% //g' | cut -d '/' -f1 | grep -v .github | uniq | sort`

            echo "TF Modules: " $CHANGED_TF_MODULES

            if [ -z "$CHANGED_TF_MODULES" ]; then
              CHANGED_TF_MODULES_JSON=$(printf '[]\n')
            else
              CHANGED_TF_MODULES_JSON=$(printf '['; for i in ${CHANGED_TF_MODULES[@]}; do printf ' \"%s\", ' $i; done | sed 's/,\([^,]*\)$/\1/'; printf ']\n')
            fi

            echo "TF Modules JSON: " $CHANGED_TF_MODULES_JSON
          fi

          echo "::set-output name=tf_modules::$CHANGED_TF_MODULES_JSON"

  static-analysis:
    needs: [ get_target_modules ]
    runs-on: ubuntu-latest
    if: needs.get_target_modules.outputs.tf_modules != '[]'
    strategy:
      matrix:
        TF_MODULE: "${{ fromJson(needs.get_target_modules.outputs.tf_modules) }}"
    steps:
    - name: Checkout application GitHub repo
      uses: actions/checkout@v3

    - name: Setup Terraform  
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.11

    - name: Terraform Format
      id: fmt
      run: terraform -chdir=${{ matrix.TF_MODULE }} fmt -check

    - name: Terraform Init
      id: init
      run: terraform -chdir=${{ matrix.TF_MODULE }} init

    - name: Terraform Validate
      id: validate
      run: terraform -chdir=${{ matrix.TF_MODULE }} validate

    # - uses: actions/cache@v2
    #   name: Cache plugin dir
    #   with:
    #     path: ~/.tflint.d/plugins
    #     key: tflint-${{ hashFiles('.tflint.hcl') }}
    
    # - name: Setup TFLint
    #   uses: terraform-linters/setup-tflint@v2
    #   with:
    #     tflint_version: v0.38.1

    # - name: Init TFLint
    #   run: tflint --init

    # - name: Run TFLint
    #   run: tflint -chdir=${{ matrix.TF_MODULE }}

    # - name: Get AWS Access Key ID
    #   id: aws_access_key_id
    #   uses: varun-charan/pyaction@v0.5.0
    #   env:
    #     VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
    #     VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
    #   with:
    #     devops_version: "v0.5.0"
    #     index_url_pip: ${{ secrets.INDEX_URL_PIP }}
    #     export_list: "VAULT_ADDR=${{ env.VAULT_ADDR }}, VAULT_TOKEN=${{ env.VAULT_TOKEN }}"
    #     command: "vault"
    #     subcommand: "get"
    #     args: "prd/devops/aws/api-users/barco-eci-sandbox AWS_ACCESS_KEY_ID"
    
    # - name: Get AWS Secret Access Key
    #   id: aws_secret_access_key
    #   uses: varun-charan/pyaction@v0.5.0
    #   env:
    #     VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
    #     VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
    #   with:
    #     devops_version: "v0.5.0"
    #     index_url_pip: ${{ secrets.INDEX_URL_PIP }}
    #     export_list: "VAULT_ADDR=${{ env.VAULT_ADDR }}, VAULT_TOKEN=${{ env.VAULT_TOKEN }}"
    #     command: "vault"
    #     subcommand: "get"
    #     args: "prd/devops/aws/api-users/barco-eci-sandbox AWS_SECRET_ACCESS_KEY"

    # - name: Terraform Plan
    #   env:
    #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    #   id: plan
    #   run: |
    #     echo "::add-mask::$AWS_ACCESS_KEY_ID"
    #     echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
    #     echo "::add-mask::$AWS_SESSION_TOKEN"
    #     export AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID }}
    #     export AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY }}
    #     export AWS_SESSION_TOKEN=${{ env.AWS_SESSION_TOKEN }}
    #     terraform -chdir=${{ matrix.TF_MODULE }} plan -var-file=.ci/tfplan.tfvars
    #   continue-on-error: false

  perform_security_scan:
    needs: [ get_target_modules ]
    uses: varun-charan/reusable-workflows/.github/workflows/iac-security-scans.yaml@master
    with:
      upload_sarif: true
      target_dirs: ${{ needs.get_target_modules.outputs.tf_modules }}
      severity: "low"
      terrascan_iac_type: "terraform"
      terrascan_iac_version: "v15"
    secrets:
      snyk_auth_token: ${{ secrets.SNYK_AUTH_TOKEN }}

  calculate_infra_cost:
    needs: [ get_target_modules ]
    uses: varun-charan/reusable-workflows/.github/workflows/calculate-infracost.yaml@master
    with:
      target_dirs: ${{ needs.get_target_modules.outputs.tf_modules }}
    secrets:
      infracost_api_key: ${{ secrets.INFRACOST_API_KEY }}
